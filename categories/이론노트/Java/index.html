
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="이상권의 개발노트">
    <title>Category: Java - 이상권의 개발노트</title>
    <meta name="author" content="이상권">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="이상권의 개발노트">
<meta property="og:url" content="https://earth-kor.github.io/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/index.html">
<meta property="og:site_name" content="이상권의 개발노트">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="이상권">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://earth-kor.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            이상권의 개발노트
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">이상권</h4>
                
                    <h5 class="sidebar-profile-bio"><p>미래의 백엔드 개발자</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/index"
                            
                            rel="noopener"
                            title="홈"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">홈</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tag" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="기록"
                        >
                        <i class="sidebar-button-icon fa fa-running" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">기록</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Earth-KOR"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.instagram.com/kwon_27_/?hl=ko"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="instagram"
                        >
                        <i class="sidebar-button-icon fab fa-instagram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">instagram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:lsk941017@naver.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/03/06/bulier-pattern/"
                            aria-label=": bulier-pattern"
                        >
                            bulier-pattern
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-03-06T10:33:11-08:00">
	
		    Mar 06, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>점층적 생성자 패턴 : 생성자로 필드를 세팅, ex) new UserInfo(userId, password);</li>
<li>자바빈 패턴 : Setter 메서드로 필드를 세팅, ex) userInfo.set(userId);</li>
<li>빌더 패턴</li>
</ul>
<p>점층적 생성자 패턴은 모든 인스턴스의 위치를 알아야하고 모르는 값을 전부 null로 처리해야 하기 때문에 코드의 가독성이 너무 떨어지고 인스턴스만 봤을떄는 이게 어떤 건지 잘 모를 수가 있다!</p>
<p>자바빈 패턴으로 set으로 설정하면 함수 호출 1회로 객체 생성을 끌낼 수 없음으로 객체 일관성이 일시적으로 깨질 수 있다.</p>
<h1 id="빌더-패턴"><a href="#빌더-패턴" class="headerlink" title="빌더 패턴"></a>빌더 패턴</h1><p>점층적 생성자 패턴과 자바 빈 패턴의 장점을 결합한 것이 바로 빌더 패턴이다.<br>클라이언트 코드에서 필요한 객체를 직접 생성하는 대신 그 전에 필수 인자들을 전달하여 빌더 객체를 만든 뒤, 빌더 객체에 정의된 설정 메서드들을 호출하여 인스턴스를 생성하는 것이다!</p>
<p>장점</p>
<ul>
<li>인스턴스를 생성하는데 있어서 필수적인 인자와 선택적인 인자를 구별 할 수 있다</li>
<li>선택적인 인자인 경우 보다 가독성이 좋은 코드로 인자를 넘길 수 있다.</li>
</ul>
<p>‘’’</p>
<p>CarTrip latestCarTripHasLocationCloseToFirstValidLocation = CarTrip.builder()<br>                                                                   .carId(131L).tripId(“20122815274”)<br>                                                                   .ignitionOnLocation(new Location(“[0,0]”))<br>                                                                   .ignitionOffLocation(new Location(“[37.52817,127.08676]”))<br>                                                                   .ignitionOffDateTime(LocalDateTime.parse(“2020-12-28 15:28:24”, DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”)))<br>                                                                   .ignitionOnDateTime(LocalDateTime.parse(“2020-12-28 15:27:45”, DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”)))<br>                                                                   .build();</p>
<p>‘’’</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/03/06/bulier-pattern/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/03/06/Optional/"
                            aria-label=": Optional"
                        >
                            Optional
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-03-06T10:26:58-08:00">
	
		    Mar 06, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Optional이란?</p>
<p>Optional<T>는 null이 올 수 있는 값을 감싸는 Wrapper 클래스</p>
<p>Optional.empty(). — null 일 때 </p>
<p>Optional.of(value) — 존재 할 때</p>
<p>Optional.ofNullable(value) 둘다 혼합</p>
<h1 id="Optional이-담고-있는-객체에-접근-및-사용방법"><a href="#Optional이-담고-있는-객체에-접근-및-사용방법" class="headerlink" title="Optional이 담고 있는 객체에 접근 및 사용방법 ?"></a>Optional이 담고 있는 객체에 접근 및 사용방법 ?</h1><p>IfPresent(함수)<br>Optional 객체가 non-null이 경우에 인자로 넘긴 함수를 실행하는 메서드입니다. Optional 객체가 null이면 인자로 넘긴 함수는 실행되지 않습니다.</p>
<p>isEmpty()<br>Optional 객체가 null이 경우에 인자로 넘긴 함수를 실행하는 메서드입니다. Optional 객체가 non-null이면 인자로 넘긴 함수는 실행되지 않습니다.</p>
<p>orElse<br>Optional에 담고 있는 객체가 null이 경우에 대신할 수 있는 값을 반환하는 메서드입니다. </p>
<p>orElseGet<br>orElse와 유사하지만, 다른 점은 메서드를 인자로 받고 함수에서 반환한 값을 반환하게 되어 있습니다. </p>
<p>orElseThrow<br>null인 경우에 기본 값을 반환하는 대신 예외를 던질 수 있습니다.</p>
<p>get()<br>랩핑된 객체의 연산이 끝나고 최종적으로 값을 가져옵니다.<br>null인 경우 NoSuchElementException 발생</p>
<p>fillter()를 사용한 조건부 리턴</p>
<p>‘’’<br>Integer year = 2019;<br>Optional<Integer> yearOptional = Optional.of(year);<br>boolean is2019 = yearOptional.filter(y -&gt; y == 2019).isPresent();<br>assertTrue(is2019);<br>boolean is2020 = yearOptional.filter(y -&gt; y == 2020).isPresent();<br>assertFalse(is2020);<br>‘’’</p>
<p>Optional vs 일반객체</p>
<p>Optional 같은 경우는 결과값에대한 null check가 가능하기 때문에 NPE 에러를 사전에 잡을 수 있다.<br>히지만 wrapper Class로 감싸서 다니기 때문에 힙 메모리에 상당한 영향을 끼칠 수 있다!<br>그래서  Optional을 쓸 때는 이 데이터의 사용 빈도를 체크해봐야한다. 사용 빈도가 많을수록 많은 데이터를 먹게되어 optional을 사용하는게 엄청나게 느려지게 할 수 있기 때문이다 ! </p>
<p>JPA에서는 findById는 Optional로 가져오고 ( 우리가 따로 객체로 형태로 받을 수 있도록 할 수 있음! )<br>getOne은 객체 형태로 가져올 수 있다! getone을 하더라도 결과값에 Optional을 wrap 해서 null 체크를 할 수도 있다</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/03/06/Optional/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/03/06/Method/"
                            aria-label=": Array Method"
                        >
                            Array Method
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-03-06T10:20:21-08:00">
	
		    Mar 06, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="Array-Method"><a href="#Array-Method" class="headerlink" title="Array Method"></a>Array Method</h1><p>Array.from()<br>console.log(Array.from(‘foo’));<br>// expected output: Array [“f”, “o”, “o”]</p>
<p>console.log(Array.from([1, 2, 3], x =&gt; x + x));<br>// expected output: Array [2, 4, 6]</p>
<p>console.log(Array.from({ a: ‘1’, b: ‘2’ }));<br>// [] : object는 빈 배열로 리턴된다.</p>
<p>let obj = { a: ‘1’, b: ‘2’ };<br>Array.from(Object.keys(obj));<br>// [“a”, “b”]<br>Array.from(Object.values(obj));<br>// [“1”, “2”]</p>
<p>Array.of()<br>Array.of(7);       // [7]<br>Array.of(1, 2, 3); // [1, 2, 3]<br>Array.of(undefined); // [undefined]</p>
<p>Array(7);          // [ , , , , , , ]<br>Array(1, 2, 3);    // [1, 2, 3]</p>
<p>Array.prototype.concat()<br>기존배열을 변경하지 않습니다.<br>추가된 새로운 배열을 반환합니다.<br>중첩 배열 내부로 재귀하지 않습니다.</p>
<p>const alpha = [‘a’, ‘b’, ‘c’];<br>const numeric = [1, 2, 3];</p>
<p>alpha.concat(numeric);<br>// 결과: [‘a’, ‘b’, ‘c’, 1, 2, 3]</p>
<p>let b = [1, 2, 3];<br>let c = [4, 5, [6, 7]];<br>b.concat(c);<br>// [1, 2, 3, 4, 5, [6, 7]]</p>
<p>Array.prototype.fill()<br>배열의 시작 인덱스부터 끝 인덱스의 이전까지 정적인 값 하나로 채웁니다.</p>
<p>var array1 = [1, 2, 3, 4];</p>
<p>// fill with 0 from position 2 until position 4<br>console.log(array1.fill(0, 2, 4));<br>// expected output: [1, 2, 0, 0]</p>
<p>// fill with 5 from position 1<br>console.log(array1.fill(5, 1));<br>// expected output: [1, 5, 5, 5]</p>
<p>console.log(array1.fill(6));<br>// expected output: [6, 6, 6, 6]</p>
<p>Array.prototype.filter()<br>주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다.<br>원본 배열은 그대로 유지.</p>
<p>var words = [‘spray’, ‘limit’, ‘elite’, ‘exuberant’, ‘destruction’, ‘present’];</p>
<p>const result = words.filter(word =&gt; word.length &gt; 6);</p>
<p>console.log(words);<br>console.log(result);<br>// Array [“spray”, “limit”, “elite”, “exuberant”, “destruction”, “present”]<br>// Array [“exuberant”, “destruction”, “present”]</p>
<p>Array.prototype.find()<br>주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.</p>
<p>var array1 = [5, 12, 8, 130, 44];</p>
<p>var found = array1.find(function(element) {<br>    return element &gt; 10;<br>});</p>
<p>console.log(found);<br>// expected output: 12</p>
<p>const inventory = [<br>    {name: ‘apples’, quantity: 2},<br>    {name: ‘bananas’, quantity: 0},<br>    {name: ‘cherries’, quantity: 5}<br>];</p>
<p>const result = inventory.find(fruit =&gt; fruit.name === ‘cherries’);</p>
<p>console.log(result) // { name: ‘cherries’, quantity: 5 }</p>
<p>Array.prototype.forEach()<br>주어진 함수를 배열 요소 각각에 대해 실행합니다.<br>forEach()는 배열을 변형하지 않습니다. 그러나 callback이 변형할 수는 있습니다.<br>예외를 던지지 않고는 forEach()를 중간에 멈출 수 없습니다.</p>
<p>Array.prototype.includes()<br>includes() 메서드는 배열이 특정 요소를 포함하고 있는지 판별합니다.</p>
<p>arr.includes(valueToFind[, fromIndex])<br>valueToFind : 탐색할 요소. 문자나 문자열을 비교할 때, includes()는 대소문자를 구분합니다.<br>fromIndex (Optional) : 이 배열에서 searchElement 검색을 시작할 위치입니다. 음의 값은 array.length + fromIndex의 인덱스를 asc로 검색합니다. 기본값은 0입니다.<br>// array length is 3<br>// fromIndex is -1<br>// computed index is 3 + (-1) = 2</p>
<p>var arr = [‘a’, ‘b’, ‘c’];</p>
<p>arr.includes(‘a’, -1); // false<br>arr.includes(‘a’, -2); // false<br>arr.includes(‘a’, -3); // true</p>
<p>var ary = [<br>    { a: ‘a’, b: ‘b’},<br>    { a: ‘aa’, b: ‘bb’}<br>];<br>ary.includes({ a: ‘a’, b: ‘b’}); // false. 객체는 확인 불가</p>
<p>Array.prototype.keys()<br>keys() 메서드는 배열의 각 인덱스를 키 값으로 가지는 새로운 Array Iterator 객체를 반환합니다.</p>
<p>Array.prototype.map()<br>map() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.<br>map이 처리할 요소의 범위는 첫 callback을 호출하기 전에 정해집니다. map이 시작한 이후 배열에 추가되는 요소들은 callback을 호출하지 않습니다.</p>
<p>var array1 = [1, 4, 9, 16];</p>
<p>// pass a function to map<br>const map1 = array1.map(x =&gt; x * 2);</p>
<p>console.log(map1); // expected output: Array [2, 8, 18, 32]<br>console.log(array1); // Array [1, 4, 9, 16] 원본 유지</p>
<p>// 아래 라인을 보시면…<br>[‘1’, ‘2’, ‘3’].map(parseInt);<br>// 결과를 [1, 2, 3] 으로 기대할 수 있습니다.<br>// 그러나 실제 결과는 [1, NaN, NaN] 입니다.</p>
<p>// parseInt 함수는 보통 하나의 인자만 사용하지만, 두 개를 받을 수 있습니다.<br>// 첫 번째 인자는 변환하고자 하는 표현이고 두 번째는 숫자로 변환할 때 사용할 진법입니다.<br>// Array.prototype.map은 콜백에 세 가지 인자를 전달합니다.<br>// 배열의 값, 값의 인덱스, 그리고 배열<br>// 세 번째 인자는 parseInt가 무시하지만 두 번째 인자는 아닙니다.</p>
<p>Array.prototype.reduce()<br>reduce() 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.</p>
<p>[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) {<br>    return accumulator + currentValue;<br>});</p>
<p>Array.prototype.shift()<br>shift() 메서드는 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다. 이 메서드는 배열의 길이를 변하게 합니다.</p>
<p>Array.prototype.slice()<br>slice() 메서드는 어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 수정되지 않습니다.</p>
<p>var animals = [‘ant’, ‘bison’, ‘camel’, ‘duck’, ‘elephant’];</p>
<p>const ary1 = animals.slice(2);<br>const ary2 = animals.slice(2, 4)</p>
<p>console.log(animals);<br>console.log(ary1);<br>console.log(ary2);</p>
<p>animals[0] = ‘aaaaa’;<br>console.log(animals);<br>console.log(ary1);</p>
<p>// Array [“ant”, “bison”, “camel”, “duck”, “elephant”]<br>// Array [“camel”, “duck”, “elephant”]<br>// Array [“camel”, “duck”]<br>// Array [“aaaaa”, “bison”, “camel”, “duck”, “elephant”]<br>// Array [“camel”, “duck”, “elephant”]</p>
<p>Array.prototype.sort()<br>sort() 메서드는 배열의 요소를 적절한 위치에 정렬한 후 그 배열을 반환합니다. 정렬은 stable sort가 아닐 수 있습니다.<br>기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따릅니다.(오름차순)</p>
<p>stable sort : 졍렬시 같은 값에 대하여 원본 순서가 유지되는 정렬<br>unstable sort : 졍렬시 같은 값에 대하여 원본 순서가 유지되지 않는 정렬</p>
<p>Array.prototype.splice()<br>splice() 메서드는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.<br>만약 제거할 요소의 수와 추가할 요소의 수가 다른 경우 배열의 길이는 달라집니다.</p>
<p>var months = [‘Jan’, ‘March’, ‘April’, ‘June’];<br>months.splice(1, 0, ‘Feb’);<br>// inserts at index 1<br>console.log(months);<br>// expected output: Array [‘Jan’, ‘Feb’, ‘March’, ‘April’, ‘June’]</p>
<p>months.splice(4, 1, ‘May’);<br>// replaces 1 element at index 4<br>console.log(months);<br>// expected output: Array [‘Jan’, ‘Feb’, ‘March’, ‘April’, ‘May’]</p>
<p>months.splice(1, 2, ‘May’);<br>console.log(months);<br>// expected output: Array [“Jan”, “May”, “April”, “May”]</p>
<p>Array.prototype.toString()<br>toString() 메서드는 지정된 배열 및 그 요소를 나타내는 문자열을 반환합니다.</p>
<p>var array1 = [1, 2, ‘a’, ‘1a’];</p>
<p>console.log(array1.toString());<br>// expected output: “1,2,a,1a”</p>
<p>Array.prototype.unshift()<br>unshift() 메서드는 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환합니다.</p>
<p>var array1 = [1, 2, 3];</p>
<p>console.log(array1.unshift(4, 5));<br>// expected output: 5</p>
<p>console.log(array1);<br>// expected output: Array [4, 5, 1, 2, 3]</p>
<p>var arr = [1, 2];</p>
<p>arr.unshift(0); // result of call is 3, the new array length<br>// arr is [0, 1, 2]</p>
<p>arr.unshift(-2, -1); // = 5<br>// arr is [-2, -1, 0, 1, 2]</p>
<p>arr.unshift([-3]);<br>// arr is [[-3], -2, -1, 0, 1, 2]</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/03/06/Method/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/23/Thread/"
                            aria-label=": Thread"
                        >
                            Thread
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-23T08:16:25-08:00">
	
		    Jan 23, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="쓰레드-Thread"><a href="#쓰레드-Thread" class="headerlink" title="쓰레드(Thread)"></a>쓰레드(Thread)</h1><p>동작하고 있는 프로그램을 프로세스(Process)라고 한다. 보통 한 개의 프로세스는 한 가지의 일을 하지만, 이 쓰레드를 이용하면 한 프로세스 내에서 두 가지 또는 그 이상의 일을 동시에 할 수 있게 된다.<br>Test클래스가 Thread 클래스를 상속했다. Thread 클래스의 run 메소드를 구현하면 위 예제와 같이 test.start() 실행 시 test객체의 run 메소드가 수행이 된다. </p>
<p>‘’’</p>
<p>public class Test extends Thread {<br>    public void run() {<br>        System.out.println(“thread run.”);<br>    }</p>
<pre><code>public static void main(String[] args) &#123;
    Test test = new Test();
    test.start();
&#125;</code></pre>
<p>}</p>
<p>‘’’</p>
<p>‘’’</p>
<p>public class Test extends Thread {<br>    int seq;<br>    public Test(int seq) {<br>        this.seq = seq;<br>    }<br>    public void run() {<br>        System.out.println(this.seq+” thread start.”);<br>        try {<br>            Thread.sleep(1000);<br>        }catch(Exception e) {</p>
<pre><code>    &#125;
    System.out.println(this.seq+&quot; thread end.&quot;);
&#125;

public static void main(String[] args) &#123;
    for(int i=0; i&lt;10; i++) &#123;
        Thread t = new Test(i);
        t.start();
    &#125;
    System.out.println(&quot;main end.&quot;);
&#125;</code></pre>
<p>}</p>
<p>‘’’</p>
<p>0번 쓰레드부터 9번 쓰레드까지 순서대로 실행이 되지 않고 그 순서가 일정치 않은 것을 보면 쓰레드는 순서에 상관없이 동시에 실행된다는 사실을 알 수 있다. 더욱 재밌는 사실은 쓰레드가 종료되기 전에 main 메소드가 종료되었다는 사실이다. main 메소드 종료 시 “main end.”라는 문자열이 출력되는데 위 결과를 보면 중간쯤에 출력되어 있다.</p>
<p>-&gt; 싱글스레드 , 멀티스레드가 따로 동작함</p>
<h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>t.join(); 쓰레드의 join 메소드는 쓰레드가 종료될 때까지 기다리게 하는 메서드이다.</p>
<p>쓰레드 프로그래밍 시 가장 많이 실수하는 부분이 바로 쓰레드가 종료되지 않았는데 쓰레드가 종료된 줄 알고 그 다음 로직을 수행하게 만드는 일이다. 쓰레드가 종료된 후 그 다음 로직을 수행해야 할 때 꼭 필요한 것이 바로 이 join 메소드이다.</p>
<h1 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h1><p>‘’’</p>
<p>import java.util.ArrayList;</p>
<p>public class Test implements Runnable {<br>    int seq;<br>    public Test(int seq) {<br>        this.seq = seq;<br>    }<br>    public void run() {<br>        System.out.println(this.seq+” thread start.”);<br>        try {<br>            Thread.sleep(1000);<br>        }catch(Exception e) {<br>        }<br>        System.out.println(this.seq+” thread end.”);<br>    }</p>
<pre><code>public static void main(String[] args) &#123;
    ArrayList&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;();
    for(int i=0; i&lt;10; i++) &#123;
        Thread t = new Thread(new Test(i));
        t.start();
        threads.add(t);
    &#125;

    for(int i=0; i&lt;threads.size(); i++) &#123;
        Thread t = threads.get(i);
        try &#123;
            t.join();
        &#125;catch(Exception e) &#123;
        &#125;
    &#125;
    System.out.println(&quot;main end.&quot;);
&#125;</code></pre>
<p>}</p>
<p>Thread t = new Thread(new Test(i));</p>
<p>‘’’</p>
<h1 id="STEP-1-프로세스와-멀티-쓰레드란"><a href="#STEP-1-프로세스와-멀티-쓰레드란" class="headerlink" title="STEP 1. 프로세스와 멀티 쓰레드란?"></a>STEP 1. 프로세스와 멀티 쓰레드란?</h1><p>프로세스 란? 실행 중인 하나의 어플리케이션 (ex : 크롬을 새 창으로 2개를 띄웠다면, 2개의 프로세스가 실행 중이라 말할 수가 있다.)<br>멀티 쓰레드 란? 하나의 프로세스가 두가지 이상의 작업을 처리할 수 있도록 하는 것이다.</p>
<p>그렇다면? 쓰레드 는 무엇일까? 바로, 한 프로세스에서 동작되는 여러 실행 흐름이라고 볼 수가 있다.<br>따라서 다시 정의를 내려보자면 아래와 같다고 볼 수가 있다.<br>프로세스는 운영체제로부터 작업을 할당받는 작업의 단위이고, 스레드는 프로세스가 할당 받은 자원을 이용하는 실행의 단위이다.</p>
<p>그렇다면, 멀티 쓰레드 는 정확히 무엇을 뜻할까? 두가지 이상의 작업을 처리 할 수 있다고 했다. 즉, 작업의 단위는 쓰레드이므로, 적어도 2개 이상의 쓰레드가 한 프로세스 내에서 처리되는 것 이 멀티 쓰레드라고 볼 수가 있다.</p>
<h1 id="STEP-1-1-멀티태스킹과-멀티쓰레딩"><a href="#STEP-1-1-멀티태스킹과-멀티쓰레딩" class="headerlink" title="STEP 1.1 멀티태스킹과 멀티쓰레딩"></a>STEP 1.1 멀티태스킹과 멀티쓰레딩</h1><p>위에서 쓰레드와 프로세스 그리고 멀티 쓰레드의 개념을 간략히 나마 배웠다. 그렇다면 멀티태스킹은 무엇이고? 멀티쓰레딩과 무슨 차이일까?</p>
<p>멀티태스킹은 여러 개의 프로세스를 동시에 실행 하는 것이다. 그렇다면, 왜 굳이 멀티태스킹(멀티프로세스)로 처리하면 될 것을 또 다시 쓰레드까지 쪼개서 처리해야될까?<br>문제는 바로 프로세스를 호출 시 발생하는 Context switch(문맥교환) 1에 있다. 프로세스는 호출할 때마다 문맥교환이라는 오버헤드가 발생하는데 스레드로 처리를 하면 프로세스끼리 통신하는 비용보다 통신 비용이 적고, 문맥교환이 적게 발생하기 때문에 보다 효율적인 작업이 가능하기 때문이다.</p>
<h1 id="STEP-1-2-멀티쓰레드의-장단점"><a href="#STEP-1-2-멀티쓰레드의-장단점" class="headerlink" title="STEP 1.2 멀티쓰레드의 장단점"></a>STEP 1.2 멀티쓰레드의 장단점</h1><p>위에서 말한 바와 같이 멀티쓰레드는 장점이 매우 많아보인다. 장점을 간략히 정리하자면 아래와 같다.</p>
<ol>
<li>CPU의 사용률을 향상시킨다.</li>
<li>자원을 보다 효율적으로 사용할 수 있다.</li>
<li>사용자에 대한 응답성이 향상된다.</li>
<li>작업이 분리되어 코드가 간결해진다.</li>
<li>멀티쓰레드의 예시로는 카카오톡을 볼 수 있다. 카카오톡은 채팅을 하면서 파일을 다운로드 받거나 음성대화를 나눌 수도 있다. 이러한 이유가 다른 작업이 가능한 멀티쓰레드 환경이기 때문이다.</li>
</ol>
<p>그러나, 멀티쓰레드가 장점만 있는 것이 아니다. 대부분의 문제는 멀티쓰레드 프로세스는 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업을 하기 때문에 동기화(Synchronization) , 교착상태(Deadlock) 와 같은 문제들이 발생할 수가 있다.</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><ol>
<li>메서드에 synchronized 하기</li>
</ol>
<p>인스턴스 메서드의 동기화는 이 메서드를 가진 인스턴스를 기준으로 이루어진다. 그러므로 한 클래스에 synchronized를 사용한 메서드를 가진다면, 여기서 동기화는 인스턴스를 기준으로 이루어진다. 그리고 오직 하나의 Thread 만이 동기화된 인스턴스 메서드를 실행할 수 있다. 결론은 synchronized를 사용한 메서드가 존재한다면 인스턴스당 한 개의 Thread만이 접근할 수 있다. 쉽게 생각하면 메서드에 synchronized를 사용하면 그 함수가 포함된 객체(this)가 lock이 걸린 것이다. </p>
<p>‘’’</p>
<p>public synchronized void withDraw(int money) {<br>    if(balance &gt;= money) {<br>        try {<br>            Thread thread = Thread.currentThread();<br>            System.out.println(thread.getName() + “ money : “ + money);<br>            Thread.sleep(1000);<br>            balance -= money;<br>            System.out.println(thread.getName() + “ balance : “ + balance);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>
<p>‘’’</p>
<ol start="2">
<li>블록에 synchronized 하기</li>
</ol>
<p>아래 synchronized 키워드 괄호 사이에 락(Lock)이라 부르는 객체를 볼 수 있다. 위에서 설명했듯이 동기화과 공유 자원에 대한 접근을 허락한다고 정의한 바 있다. 즉 synchronized 키워드는 공유 자원에 대한 범위를 지정하는 기능을 하며 synchronized() 괄호 안에 있는락 객체는 다른 스레드의 접근을 차단하거나 접근을 허용하는 일종의 자물쇠 역할을 한다. </p>
<p>‘’’</p>
<p>public void withDraw(int money) {<br>    synchronized(this) {<br>        if(balance &gt;= money) {<br>            try {<br>                Thread thread = Thread.currentThread();<br>                System.out.println(thread.getName() + “ money : “ + money);<br>                Thread.sleep(1000);<br>                balance -= money;<br>                System.out.println(thread.getName() + “ balance : “ + balance);<br>            } catch (InterruptedException  e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</p>
<p>‘’’</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/23/Thread/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/23/%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC/"
                            aria-label=": JAVA 작동원리"
                        >
                            JAVA 작동원리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-23T08:15:05-08:00">
	
		    Jan 23, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>, <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="JAVA-작동원리"><a href="#JAVA-작동원리" class="headerlink" title="JAVA 작동원리"></a>JAVA 작동원리</h1><p>자바는 ‘운영체제에 상관없이 사용될 수 있는 언어’라는 말을 들어보셨나요? 가상머신을 사용하여, 운영체제의 도움없이 자체적으로 메모리를 할당하여 프로그램이 운영될수 있도록 합니다. 또한 바이트 코드를 만든 뒤 프로그램을 실행하기 때문에 여러 운영체제에서도 사용이 될 수 있는데요 그 이유는 무엇일까요?</p>
<h2 id="JAVA의-작동-원리"><a href="#JAVA의-작동-원리" class="headerlink" title="JAVA의 작동 원리"></a>JAVA의 작동 원리</h2><p>자바의 작동원리를 간단하게 말씀드리겠습니다. java compiler는 소스파일을 컴파일하여 바이트코드로 변환시켜줍니다. 그리고 자바 가상머신은 필요한 때에 바이트 코드를 분석하여 주기억장치(메모리)에 올려줍니다. 이러한 과정을 통해서 소스파일이 실행될 수 있습니다. 잘 이해가 안가실 수 있으니 이클립스를 통해서 설명하겠습니다.</p>
<p>소스파일은 사용자가 읽거나 수정하기 쉬운 코드로 작성이 되며 작성 후 컴파일을 하면, 클래스 파일이 생성됩니다. 아래의 경로를 보시면 소스파일은 src 폴더 하위에 있지만, 클래스 파일은 build폴더 하위에 생성되는 것을 확인할 수 있습니다. 해당 경로에 들어가 클래스 파일을 열어보면 파일을 제대로 볼 수 없습니다. 기계어로 번역되어 있기 때문에 이클립스 확장 프로그램을 설치하거나 다른 방법을 사용하여 열어야 합니다. </p>
<h2 id="바이트-코드"><a href="#바이트-코드" class="headerlink" title="바이트 코드"></a>바이트 코드</h2><p>[클래스 파일과 실행]</p>
<p>바이트 코드로 작성된 클래스파일(.class)은 기계가 읽기 편하도록 만들어 놓은 파일입니다. 이 파일을 JVM이 읽어들여 실행합니다. 이 때, 클래스 파일을 실행하기 위해 필요한 모든 class 파일을 불러들이고 코드를 검증한 뒤 메모리로 올리는 작업을 합니다. 만약 클래스가 없거나 오류가 있다면 오류가 발생하고 그렇지 않다면 정상적으로 실행됩니다. </p>
<p>[클래스 파일과 이클립스]</p>
<p>클래스 파일은 이클립스에서 소스파일을 생성하거나 저장할 때 이클립스에서 자동으로 생성 및 변경해줍니다. 사용자가 해야하는 컴파일 과정을 “이클립스”라는 툴로 간편하게 실행할 수 있는 것입니다. 실제로 사용자가 자바를 이용해 컴파일을 하려면, CMD창에서 “javac 파일명.java”를 입력하여 필요한 파일을 컴파일해주어야 합니다. 이러한 과정을 이클립스가 대신 해줌으로써 개발자는 편하게 작업이 가능합니다.</p>
<p>[클래스 파일과 웹 프로젝트 ]</p>
<p>웹에서는 사용자의 요청이 있을 때, 클래스 파일이 있는지, 소스파일이 변경되었는지 확인을 합니다. 클래스 파일이 없으면 컴파일하여 클래스 파일을 생성하고, 소스파일이 변경되었으면 클래스 파일을 다시 생성합니다. 이렇게 생성된 클래스 파일을 사용하여 사용자의 요청을 처리하는데 사용합니다. 하지만, 자바는 한 번 실행되었던 클래스 파일을 캐싱하여 사용하므로 소스파일을 변경해도 클래스 파일은 기존의 것을 사용하는 경우가 있습니다. 이러한 경우에는 서버를 재실행하거나, 다른 방법을 찾아야 합니다.</p>
<h2 id="Heap-Stack-Static"><a href="#Heap-Stack-Static" class="headerlink" title="Heap/Stack/Static"></a>Heap/Stack/Static</h2><p>스택 영역<br>● heap영역에 생성된 Object 타입의 데이터 들에 대한 참조를 위한 값들이 할당. (즉, heap영역의 값에 도달하기 위한 주소값이 stack영역에 저장됨)<br>● 8가지 원시타입(byte, short, int, long, float, double, char, boolean)에 해당되는 지역변수, 매개변수 의 데이터 값이 저장되는 공간.<br>● 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제.<br>LIFO(Last In First Out) 마지막에 들어간 것이 처음으로 나오는 구조.<br>● 각각의 스레드(Thread)는 각자의 stack을 가짐.</p>
<p>힙 영역<br>● 흔히 ‘new’ 명령을 통해서 생성된 인스턴스 변수가 저장됨.<br>● 스택영역에서와 달리 힙 영역에 보관되면 메소드 호출이 끝나도 사라지지 않고 유지된다.(가비지 컬렉터에 의해서 지워지거나 JVM이 종료될때까지)<br>● 스레드(Thread)수에 상관없이 하나의 Heap 영역만 존재.<br>● 모든 Object 타입(Integer, String, ArrayList, …)은 heap 영역에 생성된다.</p>
<p>스태틱 영역<br>● 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수<br>● Static 변수와 class들이 저장되어 있음</p>
<h2 id="java-호출-순서"><a href="#java-호출-순서" class="headerlink" title="java 호출 순서"></a>java 호출 순서</h2><ol>
<li>전체가 compile되면서 선언된 class를 static에 올리고 class안에 선언되어 있는 static 변수들을 static에 올려준다.</li>
<li>public class의 main method를 먼저 호출한다.</li>
<li>밑에 순서에 따라 코드를 순차적으로 실행한다.</li>
</ol>
<p>@ static으로 선언된 변수는 클래스 변수이다. 이것은 어떤 클래스에서도 사용가능하다! 속해있는 class에 먼저 접근하고, 그 안에 static안에 담겨져있는 변수 및 메서드를 호출하면 된다!<br>@ static없이 선언된 변수는 인스턴트 변수이다. 이것을 사용하기 위해서는 new로 객체를 생성한 다음에 꺼내 쓸 수 있다!</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/23/%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 이상권. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">이상권</h4>
        
            <div id="about-card-bio"><p>미래의 백엔드 개발자</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>개발자</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Busan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover2.png');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
