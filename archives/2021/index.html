
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="이상권의 개발노트">
    <title>Archives: 2021 - 이상권의 개발노트</title>
    <meta name="author" content="이상권">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="이상권의 개발노트">
<meta property="og:url" content="https://earth-kor.github.io/archives/2021/index.html">
<meta property="og:site_name" content="이상권의 개발노트">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="이상권">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://earth-kor.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            이상권의 개발노트
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">이상권</h4>
                
                    <h5 class="sidebar-profile-bio"><p>미래의 백엔드 개발자</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/index"
                            
                            rel="noopener"
                            title="홈"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">홈</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-code" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tag" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="기록"
                        >
                        <i class="sidebar-button-icon fa fa-running" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">기록</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Earth-KOR"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.instagram.com/kwon_27_/?hl=ko"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="instagram"
                        >
                        <i class="sidebar-button-icon fab fa-instagram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">instagram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:lsk941017@naver.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/%EC%9B%90%EB%A6%AC/"
                            aria-label=": 자바스크립트 동작 원리"
                        >
                            자바스크립트 동작 원리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:32:52-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="자바스크립트-동작-원리"><a href="#자바스크립트-동작-원리" class="headerlink" title="자바스크립트 동작 원리"></a>자바스크립트 동작 원리</h1><p>‘’’<br>// ex)<br>console.log(‘Start!’)</p>
<p>setTimeout(() =&gt; {<br>Console.log(’Timeout!’)<br>}, 0)</p>
<p>Promise.resolve(‘Promise!’)<br>.then(res =&gt; console.log(res))</p>
<p>console.log(‘End!’)<br>‘’’</p>
<p>맨 처음 라인에서 엔진은 console.log()를 마주친다 이는 “Start!”라고 값이 콘솔에 찍히고 나서 call stack에 추가된다. 해당 메소드는 call stack에서 빠져나가고 엔진은 계속해서 실행된다.</p>
<p>그 다음 엔진은 call stack으로 들어간 setTimeout메소드를 맞닥뜨린다.setTimeout 메소드는 브라우저의 native 메소드이다.<br />타이머가 끝날때까지 그것의 콜백 함수인 ()=&gt;console.log(‘In timeout’)은되 Web API에 추가된다.<br>비록 우리는 타이머에 0이라는 값을 넣었지만, 콜백은 먼저 Web API에 들어갈 것이고, 그 다음엔 (macro)task queue에 추가될 것이다. (setTimeout은 <b>macro task</b>이다!)</p>
<p>그 다음 엔진은 Promise.resolve() 메소드와 마주침<br>Promise.resolve() 메소드는 call stack에 추가되고, 그다음엔 “Promise!” 라는 값으로 resolve된다<br>해당 메소드의 then 콜백 함수가 micro task queue에 추가된것이다</p>
<p>엔진은 callstack이 비어있는 것을 발견한다<br>Call stack이 비어있기 때문에 엔진은 micro task queue에 작업들이 있는지 체크한다<br>그리고 거기거 promise then의 콜백이 작신의 차례를 기다리고 있는 것을 찾아낸다!<br>그것은 call stack으로 들어가고 promise의 resolve된 값들을 로그로 찍는다.</p>
<p>이제 엔진은 call stack이 비어진 것을 보고 micro task queue를 다시 한번 체크 할 것이다.<br>하지만 이제 microtask queue에는 아무것도 남아 있지 않다</p>
<p>이제 macrotask queue를 체크 할 차례이다!<br>앞서 과정을 반복한다!</p>
<p>출처 : <a target="_blank" rel="noopener" href="https://kkangdda.tistory.com/77">https://kkangdda.tistory.com/77</a></p>
<h1 id="태스크-큐-vs-마이크로태스크-큐"><a href="#태스크-큐-vs-마이크로태스크-큐" class="headerlink" title="태스크 큐 vs 마이크로태스크 큐"></a>태스크 큐 vs 마이크로태스크 큐</h1><p>2개의 큐 모두 콜백함수가 들어간다는 점에서 동일하지만 어떤 함수를 실행하느냐에 따라 어디로 들어가는지가 달라진다. 또한 명칭은 큐 (Queue) 이지만 실제 우리가 아는 자료구조의 큐와는 다르다. 엄밀히 말하자면 우선순위 큐 (Priority Queue) 라고 할 수 있는데, 이벤트 루프가 2개의 큐에서 태스크를 꺼내는 조건이 “제일 오래된 태스크” 이기 때문이다. (동작방식을 확인하고 싶다면 HTML 스펙 을 보자)<br>그럼 이제 어떤 함수들이 어떤 큐에 들어가는지 살펴보자.</p>
<ul>
<li>콜백함수를 태스크 큐에 넣는 함수들<ul>
<li>setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링</li>
</ul>
</li>
<li>콜백함수를 마이크로태스크 큐에 넣는 함수들<ul>
<li>process.nextTick, Promise, Object.observe, MutationObserver<br>익숙한 함수인 Web API의 setTimeout() 의 콜백함수가 태스크 큐에 들어가고 Promise 의 콜백함수가 마이크로태스크 큐에 들어간다는 것을 알 수 있다. 이벤트 루프는 각 콜백함수를 태스크/마이크로태스크 큐에서 꺼내쓰는 것인데, 그렇다면 어떤게 먼저일까?</li>
</ul>
</li>
</ul>
<p>누가 먼저인가?<br>결론부터 말하자면, 마이크로태스크가 먼저이다.<br>이벤트 루프는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 태스크 큐의 태스크들을 처리한다. 따라서, Promise 의 콜백함수가 setTimeout() 의 콜백함수보다 먼저 처리된다. 예시를 보자.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/%EC%9B%90%EB%A6%AC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/%EB%B0%A9%EB%B2%95/"
                            aria-label=": setState 동기화 시키는 방법"
                        >
                            setState 동기화 시키는 방법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:31:34-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EA%B0%9C%EB%B0%9C%EB%85%B8%ED%8A%B8/">개발노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="setState-비동기를-동기화-시키는-방법"><a href="#setState-비동기를-동기화-시키는-방법" class="headerlink" title="setState 비동기를 동기화 시키는 방법"></a>setState 비동기를 동기화 시키는 방법</h1><h3 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h3><p>‘’’</p>
<p>state = { count: 0 }<br>this.setState( { count: this.state.count + 1 } );<br>this.setState( { count: this.state.count + 1 } );<br>this.setState( { count: this.state.count + 1 } );</p>
<p>import produce from ‘immer’;</p>
<p>‘’’</p>
<h3 id="동기"><a href="#동기" class="headerlink" title="동기"></a>동기</h3><p>‘’’</p>
<p>state = { count: 0 }</p>
<p>this.setState( state =&gt; (<br>  produce( state, draft =&gt; { draft.count = state.count + 1 } )<br>) );<br>this.setState( state =&gt; (<br>  produce( state, draft =&gt; { draft.count = state.count + 1 } )<br>) );<br>this.setState( state =&gt; (<br>  produce( state, draft =&gt; { draft.count = state.count + 1 } )<br>) );</p>
<p>‘’’</p>
<h1 id="setState-는-await와-사용이-가능할까"><a href="#setState-는-await와-사용이-가능할까" class="headerlink" title="setState() 는 await와 사용이 가능할까?"></a>setState() 는 await와 사용이 가능할까?</h1><p>결과를 먼저 이야기하자면 setState에는 await를 사용할 수 없다.<br>async / await 의 기반은 promise 다. async 함수는 promise를 반환하고 promise가 함수로부터 반환할 값을 resolve 한다.<br>setState는 promise를 리턴하지 않기에 await와 함께 사용할 수 없다.</p>
<p>그렇다면 setState는 어떤식으로 작동할까?<br>setState는 항상 즉시 컴포넌트를 업데이트 하지 않는다. 비동기적으로 작동하기 때문에 setState() 를 호출하고 바로 다음에 this.state를 읽으려하면 원하는 결과가 나오지 않는다.<br>componentDidUpdate 나 setState 콜백을 사용해야 원하는 결과를 얻을 수 있다.</p>
<p>‘’’</p>
<p>// 원하는 결과가 안나옴<br>This.setState({ myCabinet: ‘beer’ });<br>console.log(this.state.myCabinet);</p>
<p>// 원하는 결과가 나옴<br>this.setState({ myCabinet: ‘beer’ }, () =&gt; console.log(this.state.myCabinet));</p>
<p>‘’’</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/%EB%B0%A9%EB%B2%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0/"
                            aria-label=": enum으로 오류 제어하기"
                        >
                            enum으로 오류 제어하기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:29:44-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EA%B0%9C%EB%B0%9C%EB%85%B8%ED%8A%B8/">개발노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="오류를-제어에-필요한-enum-만들기"><a href="#오류를-제어에-필요한-enum-만들기" class="headerlink" title="오류를 제어에 필요한 enum 만들기"></a>오류를 제어에 필요한 enum 만들기</h1><h2 id="Backend"><a href="#Backend" class="headerlink" title="Backend"></a>Backend</h2><h3 id="backend-Exception-code-declear"><a href="#backend-Exception-code-declear" class="headerlink" title="backend Exception code declear"></a>backend Exception code declear</h3><p>‘’’<br>package com.imaslab.fms.enums.exception;</p>
<p>import lombok.AllArgsConstructor;<br>import lombok.Getter;</p>
<p>@AllArgsConstructor<br>@Getter<br>public enum ExceptionCode<br>{<br>    // @formatter:off<br>    // DEVICE - CAR_CONTROL<br>    IGNITION_CONTROL_NOT_SUPPORTED(40201),<br>    IGNITION_CONTROL_ALREADY_REQUESTED(40202),<br>    IGNITION_CONTROL_REQUEST_FAILED(40203),<br>    IGNITION_CONTROL_NOT_REQUESTED(40204),</p>
<pre><code>UPDATE_DEVICE_REQUEST_FAILED(40301),
ALREADY_INSTALLED_DEVICE(40302),
NOT_YET_INSTALLED_DEVICE(40303),

NOT_YET_FOTA_PACKET_RECEIVED(40304),
NOT_YET_ACTIVATION_OR_RT_PACKET_RECEIVED(40305)
;
// @formatter:on

Integer value;

private ExceptionCode(int value)
&#123;
    this.value = value;
&#125;

public int getValue()
&#123;
    return value;
&#125;</code></pre>
<p>}<br>‘’’</p>
<h3 id="backend-Exception-Error-Code-Using"><a href="#backend-Exception-Error-Code-Using" class="headerlink" title="backend Exception Error Code Using"></a>backend Exception Error Code Using</h3><p>‘’’<br>throw new InvalidParameterException();</p>
<p>public class InvalidParameterException extends AbstractException<br>{</p>
<pre><code> public InvalidParameterException()
&#123;
    super(&quot;Invalid Parameter&quot;, &quot;&quot;, ExceptionCode.INVALID_PARAMETER, null);
&#125;

public InvalidParameterException(String parameterName)x
&#123;
    super(&quot;Invalid Parameter&quot;, parameterName, ExceptionCode.INVALID_PARAMETER);
&#125;

public InvalidParameterException(String parameterName, ExceptionCode exceptionCode)
&#123;
    super(&quot;Invalid Parameter&quot;, parameterName, exceptionCode);
&#125;</code></pre>
<p>}</p>
<p>‘’’</p>
<h3 id="backend-Exception-extends-AbstractException"><a href="#backend-Exception-extends-AbstractException" class="headerlink" title="backend Exception extends AbstractException"></a>backend Exception extends AbstractException</h3><p>‘’’<br> @Data<br> @EqualsAndHashCode(callSuper = true)<br> public abstract class AbstractException extends RuntimeException<br> {</p>
<pre><code>String description;
ExceptionCode code;
Throwable t;

public AbstractException(String message, String description, ExceptionCode code, Throwable t)
&#123;
    super(message);
    this.description = description;
    this.code = code;
    this.t = t;
&#125;</code></pre>
<p>}</p>
<p>‘’’</p>
<h2 id="FrontEnd"><a href="#FrontEnd" class="headerlink" title="FrontEnd"></a>FrontEnd</h2><h3 id="FrontEnd-Exception-code-declear"><a href="#FrontEnd-Exception-code-declear" class="headerlink" title="FrontEnd Exception code declear"></a>FrontEnd Exception code declear</h3><p>‘’’<br>export enum constants {</p>
<pre><code>INTERNAL_SERVER_ERROR = &#39;서버에 오류가 발생하였습니다.&#39;,
REQUEST_TIMEOUT = &#39;요청 시간을 초과하였습니다.&#39;,

REQUIRE_AUTHENTICATION = &#39;인증이 필요합니다.&#39;,
INVALID_JWT_TOKEN = &#39;유효하지 않은 토큰입니다.&#39;,
EXPIRED_TOKEN = &#39;만료된 토큰입니다.&#39;,
EXPIRED_REFRESH_TOKEN = &#39;장기 미접속 상태로 로그인이 필요합니다.&#39;,

MISMATCH_EMAIL = &#39;아이디가 존재하지 않습니다.&#39;,
MISMATCH_PASSWORD = &#39;비밀번호가 일치하지 않습니다.&#39;,
BLOCKING_ACCOUNT = &#39;서비스가 정지된 이용자입니다.&#39;,

THINGPLUG_RPC_FAILED = &#39;ThingPlug RPC 요청을 실패하였습니다.&#39;,

CAR_DB_INSTALLATION_FAILURE_CASE = &#39;차량 DB 적용 실패&#39;,
CAR_DB_FORMAT_ERROR = &#39;차량 DB 형식 오류&#39;,

ALREADY_CONNECTED_CAR = &#39;이미 현장서비스에 등록된 예약 입니다. 차량번호를 다시 확인해주세요&#39;</code></pre>
<p>  }<br>‘’’</p>
<h3 id="frontend-Exception-Error-Code-Using"><a href="#frontend-Exception-Error-Code-Using" class="headerlink" title="frontend Exception Error Code Using"></a>frontend Exception Error Code Using</h3><p>‘’’</p>
<p>import { constants } from ‘../../../enum/ExceptionCode’;</p>
<p>Api.saveOnsiteService(appCtx.getAuthToken(),onsiteServiceforPost).then(<br>                        resp=&gt; {<br>                            if (resp.ok) {<br>                                IMASWindow.alert(‘현장서비스 등록이 완료되었습니다!’)<br>                                window.history.back()<br>                            } else {<br>                                if(resp.code = 30109) {<br>                                    IMASWindow.alert( constants.ALREADY_CONNECTED_CAR )<br>                                    return;<br>                                }<br>                                IMASWindow.alert(‘현장서비스 등록을 실패하였습니다.(‘ + resp.code + ‘)’)<br>                            }<br>                        }<br>                    ).catch(e =&gt; {IMASWindow.alert(‘현장서비스 등록을 실패하였습니다.(‘ + e + ‘)’)}</p>
<p>‘’’</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/JPQL/"
                            aria-label=": JPQL"
                        >
                            JPQL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:28:32-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="JPQL-Java-Persistence-Query-Language"><a href="#JPQL-Java-Persistence-Query-Language" class="headerlink" title="JPQL ( Java Persistence Query Language )"></a>JPQL ( Java Persistence Query Language )</h1><p>JPQL은 SQL과 비슷한 문법을 가진 객체 지향 쿼리입니다.</p>
<p>JPQL의 탄생 배경은 JPA에서 제공하는 메서드 호출만으로 섬세한 쿼리 작성이 어렵다는 것에 있습니다.<br>이전 글 CURD에서는 SELECT 쿼리를 위해 JPQL을 사용했지만, EntityManager 객체의 find() 메서드를 호출하여 SELECT 쿼리를 수행 할 수도 있습니다.<br>Book book = em.find(Book.class, 1);<br>find() 메서드는 식별자를 통해서만 데이터 조회를 하며, 조건문도 없고 모든 칼럼을 조회하는 메서드입니다.<br>이것만 가지고는 조금이라도 복잡한 검색을 수행할 수가 없습니다.<br>따라서 여러 조건을 통해 검색을 하는 방법이 필요했고, 그래서 JPQL이 개발되었습니다.</p>
<p>JPQL 특징</p>
<ol>
<li>테이블이 아닌 객체를 검색하는 객체지향 쿼리</li>
<li>SQL을 추상화 했기 때문에 특정 벤더에 종속적이지 않음</li>
<li>JPA는 JPQL을 분석하여 SQL을 생성한 후 DB에서 조회</li>
</ol>
<p>기본 문법<br>String jpql = “select c from Category c “;<br>JPQL은 SQL과 문법이 매우 유사하지만 몇 가지 다른 점이 있습니다.</p>
<ol>
<li><p>대소문자 구분<br>엔티티와 속성은 대소문자를 구분합니다.<br>예를 들어 엔티티 이름인 User, User 엔티티의 속성인 email은 대소문자를 구분합니다.<br>반면에 SELECT , FROM , AS 같은 JPQL 키워드는 대소문자를 구분하지 않습니다.</p>
</li>
<li><p>엔티티 이름<br>위의 예제에서 select c from 뒤에 나오는 Category는 엔티티 이름입니다.<br>Category가 클래스 이름이라고 착각할 수 있는데, 그것이 아니라 @Entity( name=”Category” )로 설정한 엔티티 이름입니다.<br>참고로 name 속성을 생략하면 기본 값으로 클래스 이름을 사용합니다.</p>
</li>
<li><p>별칭<br>select c from Category c 에서 c라는 별칭을 주었습니다.<br>JPQL에서 엔티티의 별칭은 필수적으로 명시해야 합니다.<br>별칭을 명시하는 AS 키워드는 생략할 수 있습니다.</p>
</li>
</ol>
<p>JPQL은 복잡한 검색을 위해 사용되기 때문에 INSERT , UPDATE , DELETE 쿼리는 엔티티 매니저가 직접 호출하도록 하는 것이 좋습니다.<br>그래서 이 글에서도 SELECT 쿼리에 초점을 맞춰 JPQL을 알아보도록 하겠습니다.</p>
<p>TypedQuery</p>
<p>‘’’<br>public static void typedQuery(EntityManager em) {<br>    String jpql = “SELECT b FROM Book b “;<br>    TypedQuery<Book> query = em.createQuery(jpql, Book.class);</p>
<pre><code>List&lt;Book&gt; bookList = query.getResultList();
for( Book book : bookList) &#123;
    System.out.println(book.getTitle());
&#125;</code></pre>
<p>}<br>‘’’<br>모든 책 리스트를 조회하는 쿼리입니다.</p>
<p>EntityManager 객체에서 createQuery() 메서드를 호출하면 쿼리가 생성됩니다.<br>TypedQuery는 반환되는 엔티티가 정해져 있을 때 사용하는 타입이며,<br>em.createQuery 메서드를 호출할 때 두 번째 인자로 엔티티 클래스를 넘겨줍니다.</p>
<p>TypedQuery 객체의 getResultList() 메서드를 호출하면 작성한 JPQL에 의해 데이터를 검색하며, List 타입으로 반환합니다.</p>
<p>Query</p>
<p>‘’’<br>public static void Query(EntityManager em) {<br>    String jpql = “SELECT b.no, b.title FROM Book b”;<br>    Query query = em.createQuery(jpql);</p>
<pre><code>List&lt;Object&gt; list = query.getResultList();
for( Object object : list ) &#123;
      Object[] results = (Object[]) object;

      for( Object result : results ) &#123;
          System.out.print ( result );
     &#125;
     System.out.println();
  &#125;</code></pre>
<p>}<br>‘’’</p>
<p>TypedQuery와 달리 Query 타입은 데이터 검색 결과의 타입을 명시하지 않습니다.<br>그래서 List의 제네릭 타입으로 Object를 작성했습니다.</p>
<p>그리고 변수 jpql에서 SELECT 하는 칼럼을 선택적으로 명시한 점을 주목해주세요.<br>Query 타입을 사용하면 이런 식으로 여러 개의 칼럼을 선택적으로 명시할 수 있습니다.</p>
<p>‘’’<br>public static void Query(EntityManager em) {<br>    String jpql = “SELECT b.no, b.title FROM Book b”;<br>    TypedQuery<Book> query = em.createQuery(jpql, Book.class);</p>
<pre><code>List&lt;Book&gt; bookList = query.getResultList();
for( Book book : bookList ) &#123;
    System.out.println(book.getTitle());
&#125;</code></pre>
<p>}<br>‘’’<br>위와 같이 여러 개의 칼럼을 선택적으로 명시한 후, TypedQuery를 선언하면 에러가 발생합니다.</p>
<p>setParameter (1) - 이름 기준 파라미터 바인딩<br>‘’’<br>public static void namedParameter(EntityManager em, String param1) {<br>    String jpql = “SELECT b FROM Book b WHERE title = :foo”;<br>    TypedQuery<Book> query = em.createQuery(jpql, Book.class);<br>    query.setParameter(“foo”, param1);</p>
<pre><code>List&lt;Book&gt; bookList = query.getResultList();
for( Book book : bookList) &#123;
    System.out.println(book.getTitle());
&#125;</code></pre>
<p>}<br>‘’’<br>SELECT 쿼리를 수행할 때 항상 고정된 데이터를 조회하지 않을 수 있습니다.<br>예를들어 게시판에서 글 제목을 검색할 때 사용자가 검색하는 키워드는 유동적입니다.<br>따라서 동적으로 데이터가 바인딩 되기 위한 방법이 필요합니다.</p>
<p>위의 예제에서 사용한 방법은 이름을 기준으로 파라미터를 바인딩 하는 방법입니다.<br>콜론( : )을 사용하여 데이터가 추가될 곳을 지정해주고,<br>query.setParameter() 메서드를 호출하여 데이터를 동적으로 바인딩 합니다.</p>
<p>이제 DTO를 사용하는 방법에 대해 알아보겠습니다.</p>
<p>‘’’<br>// DTO 사용 ( new 명령어 )<br>public static void useDTO (EntityManager em) {<br>    String jpql = “SELECT new com.victolee.example.dto.BookDTO(b.no, b.title) FROM Book b”;<br>    TypedQuery<BookDTO> query = em.createQuery(jpql, BookDTO.class);</p>
<pre><code>List&lt;BookDTO&gt; list = query.getResultList();
for( BookDTO dto : list) &#123;
    System.out.println(dto.getTitle());
&#125;</code></pre>
<p>}<br>‘’’</p>
<p>JPQL이 조금 지저분합니다.<br>SELECT와 FROM 사이에 new라는 키워드로 BookDTO를 생성하는 것처럼 보입니다.<br>( new 키워드 뒤에 DTO의 패키지명까지 작성해야 한다는 것에 주의하세요. )<br>이 때 new는 객체를 생성하라는 의미가 아니라 JPQL에서 지원하는 new 키워드입니다.</p>
<p>BookDTO에서 생성자를 오버로딩한 이유는 위와 같이 JPQL을 작성하기 위함입니다.<br>즉 BookDTO 객체 필드 값으로 쿼리의 결과 값을 할당합니다.</p>
<p>조인</p>
<p>‘’’<br>// 방법1<br>String jpql = “SELECT b.title, c.name FROM Book b, Category c WHERE b.no = b.category.no”;<br>// 방법2<br>String jpql = “SELECT b, c FROM Book b JOIN b.category c”;</p>
<p>Query query = em.createQuery(jpql);</p>
<p>List&lt;Object[]&gt; list = query.getResultList();<br>for( Object[] row : list ) {<br>     Book book = (Book)row[0];<br>     Category category = (Category)row[1];<br>}<br>‘’’</p>
<p>Book과 Category 엔티티가 관계를 맺고 있을 때, 조인을 하는 방법입니다.<br>아직 두 엔티티를 매핑하는 연관 관계 매핑에 대해 다루지 않았지만 JPQL을 다룰 때 한꺼번에 정리를 하려고 합니다.</p>
<p>서로 다른 두 엔티티를 조회 했으므로 TypedQuery 타입으로 반환할 수 없습니다.</p>
<p>방법2에서 주의할 것은 join 할 때 FROM Book b JOIN Category c 와 같이 SQL처럼 작성하면 안됩니다.</p>
<p>그런데 join 조회 결과를 캐스팅하여 사용하는 것이 번거로우므로 DTO를 사용하는 것이 훨씬 깔끔할 것 같습니다.<br>어쨋든 조인은 이런 식으로 사용할 수 있습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/JPQL/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/"
                            aria-label=": JPA에서의 Sort 문제해결"
                        >
                            JPA에서의 Sort 문제해결
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:27:09-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EA%B0%9C%EB%B0%9C%EB%85%B8%ED%8A%B8/">개발노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="JPA-안의-sort-사용-시-자동으로-테이블을-지정-할-때-다른-테이블로-바꾸는-방법"><a href="#JPA-안의-sort-사용-시-자동으로-테이블을-지정-할-때-다른-테이블로-바꾸는-방법" class="headerlink" title="JPA 안의 sort 사용 시 자동으로 테이블을 지정 할 때, 다른 테이블로 바꾸는 방법"></a>JPA 안의 sort 사용 시 자동으로 테이블을 지정 할 때, 다른 테이블로 바꾸는 방법</h1><p> Sort sort = Sort.by(Collections.emptyList());</p>
<pre><code>    for (Sort.Order order : pageable.getSort())
    &#123;
        switch (order.getProperty())
        &#123;
            case &quot;requestedCompanyName&quot;:
                sort = sort.and(JpaSort.unsafe(order.getDirection(), &quot;FU.company.name&quot;));
                break;
            case &quot;requestedBranchName&quot;:
                sort = sort.and(JpaSort.unsafe(order.getDirection(), &quot;FU.branch.name&quot;));
                break;
            case &quot;requestedUserName&quot;:
                sort = sort.and(JpaSort.unsafe(order.getDirection(), &quot;FU.name&quot;));
                break;
            default:
                sort = sort.and(Sort.by(order.getDirection(), order.getProperty()));
                break;
        &#125;
    &#125;

    return userReportRepository.fetchAllByParameters
        (
            type, step, reportedUserId, reportedCompanyId, reportedBranchId, processedUserId, searchKeyword,
            reportedDateTimeFrom, reportedDateTimeTo, processedDateTimeFrom, processedDateTimeTo,
            PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), sort)
        );



JpaSort.unsafe : 자동으로 테이블으 지정하는 것으 막아준다
JpaSort.unsafe (a,b) : a는 desc, asc 같은것들 , b는 테이블 지정
order.getDirection() : 원래의 a를 가져온다
order.getProperty() : 원래의 b를 가져온다
PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), sort) : 위의 조건을 사용 할 시 넘겨주는 파라미터 형태</code></pre>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/16/JPA/"
                            aria-label=": JPA"
                        >
                            JPA
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-16T08:25:11-08:00">
	
		    Jan 16, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="Jpa"><a href="#Jpa" class="headerlink" title="Jpa"></a>Jpa</h1><ol>
<li>JPA(Java Persistence API)?</li>
</ol>
<p>RDBMS 와 OOP 객체 사이의 불일치에서 오는 패러다임을 해결하기 위해<br>자바는 ORM(Object-Relational Mapping) 기술을 만들어 냈다.<br>문자 그대로 ORM 은 객체와 RDBMS 를 매핑하는 역할을 한다.<br>￼<br>ORM 기술을 구현하기 위해 만들어져 사용되어 온 프레임워크가 Hibernate 이고,<br>시간이 지나면서 Hibernate 이외에도 ORM 기술을 구현하는 프레임워크(TopLink, CoCobase) 가 등장하였다.<br>그리고 이런 ORM 기술을 구현한 프레임워크에 대한 표준화가 이루어 졌는데,<br>그 결과로 만들어진 것이 JPA 인 것이다.<br> <br>JDBC API 가 어플리케이션과 DMBS 사이에서 인터페이스 역할을 해 주기 때문에,<br>개발자는 사용할 DB 의 드라이버만 변경해 주면 되는 것처럼,<br>(DB 드라이버는 JDBC 표준에 맞추어 DB 관련 처리가 구현되어 있고, DB 드라이버는 각 DB 회사가 알아서 만들어 놓았다)<br>개발자는 ORM 을 기술을 사용할 때, JPA 인터페이스에 맞추어 구현되어 있는 <br>Hibernate, TopLink, CoCoBase 프레임워크 중 골라서 사용하면 된다.<br>만약, JPA 같은 표준 인터페이스가 없다면, <br>ORM 기술을 사용하기 위한 Hibernate, TopLink, CoCoBase 의 필드와 메소드가 다를 것이다.<br>같은 기능을 가지는 메소드인데 Hibernate 에서는 냥냥고고( ), TopLink 에서는 멍멍고고( )로 정의되어 있다면,<br>사용하는 개발자가 ORM 프레임워크를 변경해야 할 때 난감할 것이다.<br>그래서 JPA API 가 이 기능은 통일해서 냥이최고( ) 로 구현하라고 강제하는 것이다(인터페이스의 중요 기능).<br> <br>ORM 프레임워크를 사용하면 개발자가 객체를 데이터베이스에 저장할 때 SQL을 직접 작성할 필요 없이,<br>자바 컬렉션에 저장하는 것처럼 ORM 프레임워크에 저장하면 된다.<br>객체를 받은 ORM 프레임워크는 저장된 자바 객체를 분석해서 적절한 SQL을 생성하고 데이터베이스에 저장시킨다.  <br> <br> 지연 로딩과 즉시 로딩</p>
<ol>
<li>지연 로딩 : 객체가 실제 사용될 때 로딩</li>
<li>즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회</li>
</ol>
<ol start="2">
<li>영속성(Persistence)</li>
</ol>
<p>(1) Entity Class<br>엔티티 클래스는 자바 클래스에 @Entity 어노테이션을 붙여, 테이블과 매핑한다고 JPA 에게 알려주는 클래스다.<br>그리고 엔티티 클래스에서 만들어진 객체를 엔티티라고 한다.</p>
<p>(2) 영속성 컨텍스트(Persistence Context)<br>영속성 컨텍스트는 엔티티 클래스에서 만들어지는 엔티티를 영구 저장하고 관리하는 환경이다.</p>
<p>영속성 컨텍스트 와 관련한 엔티티의 4가지 상태<br> ① 비영속(new/transient) - 엔티티 객체가 만들어져서 아직 저장되지 않은 상태로, 영속성 컨텍스트와 전혀 관계가 없는 상태<br> ② 영속(managed) - 엔티티가 영속성 컨텍스트에 저장되어, 영속성 컨텍스트가 관리할 수 있는 상태<br> ③ 준영속(detached) - 엔티티가 영속성 컨텍스트에 저장되어 있다가 분리된 상태로, 영속성 컨텍스트가 더 이상 관리하지 않는 상태<br> ④ 삭제(removed) - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제</p>
<p>영속성 컨텍스트의 특징<br> ① 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본키와 매핑한 필드 값)으로 구분한다. <br>     그렇기 때문에 영속 상태는 식별자 값이 반드시 있어야 한다.<br> ② 영속성 컨텍스트에 엔티티를 저장하면 바로 데이터베이스에 저장되는 것이 아니라, 1차 캐시에 엔티티를 생성하고,<br>     쓰기 지연 SQL 저장소에 쿼리문을 생성해서 저장한다. 이렇게 쌓인 쿼리문은 flush( )가 실행될 때 데이터베이스에 반영된다.</p>
<p>(3) 엔티티 생성</p>
<ol>
<li>자바 어플리케이션에서 어떤 엔티티가 만들어져서 JPA에게 데이터베이스 저장을 부탁하면,</li>
<li>만들어진 엔티티는 1차적으로 영속성 컨텍스트에 저장된다. 1차 캐시 정도라고 생각하면 된다.<br>   그리고, 저장한 엔티티를 데이터베이스에 저장하기 위한 쿼리문을 생성시켜 쓰기 지연 SQL 저장소에  저장한다.<br>   계속해서 엔티티를 넘기면 엔티티들과 쿼리문들은 차곡차곡 영속성 컨텍스트에 저장된다.</li>
<li>그러다가 자바 어플리케이션에서 커밋 명령이 내려지면 영속 컨텍스트에는 자동으로 flush( )가 호출되고,</li>
<li>영속성 컨텍스트의 변경내용을 데이터베이스와 동기(flush)화 한다(SQL 저장소의 쿼리를 실행시킨다).</li>
<li>마지막으로 데이터베이스에게 commit 쿼리문을 명령한다.<br>￼
 </li>
</ol>
<p>(4) 엔티티 조회 </p>
<ol>
<li>자바 어플리케이션에서 JPA에게 데이터베이스 조회를 부탁하면,<br>   1차적으로 영속성 컨텍스트에서 엔티티를 찾는다. </li>
<li>있으면 자바 어플리케이션에 엔티티를 넘긴다.</li>
<li>영속성 컨텍스트에 없는 엔티티 조회를 부탁하면</li>
<li>쿼리문을 사용해 데이터베이스에서 찾아와 </li>
<li>영속성 컨텍스트에 엔티티로 저장하고</li>
<li>자바 어플리케이션에 그 엔티티를 넘긴다.<br>￼
 </li>
</ol>
<p>(5) 엔티티 변경<br>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초의 상태를 복사해서 저장해 두는데,<br>이것을 스냅샷이라 한다.</p>
<ol>
<li>자바 어플리케이션에서 커밋 명령이 들어오면, 영속 컨텍스트에는 자동으로 flush( )가 호출되고,</li>
<li>엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.</li>
<li>변경된 엔티티가 있으면 데이터베이스에 변경사항을 저장하기 위해 쿼리를 생성하고,</li>
<li>영속성 컨텍스트의 변경내용을 데이터베이스와 동기(flush)화 한다(SQL 저장소의 쿼리를 실행시킨다).</li>
<li>마지막으로 데이터베이스에게 commit 쿼리문을 명령한다.<br>￼<br>이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경감지(Dirty Checking)이라 한다.<br> <br> <br>(6) 엔티티 삭제<br>앞의 과정과 마찬가지로, 자바 어플리케이션에서 엔티티 삭제 명령이 들어오면,<br>엔티티를 찾고 쓰기 지연 SQL 저장소에 delete 쿼리를 생성한다.<br>그리고 자바 어플리케이션에서 커밋 명령이 들어오면, 자동으로 flush( )가 호출되고,<br>영속성 컨텍스트의 변경내용을 데이터베이스와 동기(flush)화 한다(SQL 저장소의 쿼리를 실행시킨다).<br>마지막으로 데이터베이스에게 commit 쿼리문을 명령한다. 
 </li>
<li>JPA 메소드<br>(1) flush( )<br>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.</li>
</ol>
<p>실행되었을 때 일어나는 일<br>  ① 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샵과 비교해서 수정된 엔티티를 찾고,<br>      수정된 엔티티를 데이터베이스에 반영하기 위해 수정 쿼리를 생성하여 지연 SQL 저장소에 등록<br>  ② 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 전송(등록, 수정, 삭제 쿼리)<br>  <br>보통 직접 사용하지 않고, 자바 어플리케이션에서 커밋 명령이 들어왔을 때, 자동으로 실행된다.<br> <br>(2) detach( ) <br>특정 엔티티를 준영속 상태로 만든다. <br>준영속 상태가 된 엔티티는 더이상 영속 컨텍스트의 관리를 받지 않으며,<br>영속 컨텍스트가 지원하는 어떤 기능도 동작하지 않게 된다.<br>영속 상태가 영속성 컨텍스트로에게 관리(managed)되는 상태라고 하면,<br>준영속 상태는 영속성 컨텍스트로부터 분리(detached)된 상태이다.<br> <br>(3) clear( )<br>영속성 컨텍스트를 초기화 한다.<br>영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.<br> <br>(4) close( )<br>영속성 컨텍스트를 종료한다.<br>영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모둔 준영속 상태가 된다.<br> <br>영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다.<br>개발자가 직접 준영속 상태로 만드는 일은 거의 없다.<br> <br>(5) merge( )<br>준영속 상태의 엔티티의 특징<br> ① 거의 비영속 상태에 가깝다. 영속성 컨텍스트가 관리하지 않으므로 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.<br> ② 식별자 값을 가지고 있다. 비영속 상태의 엔티티는 식별자(엔티티를 구분하기 위한 유일한 값, ID)를 가지지 않고 있을 수도 있지만,<br>     준영속 상태는 이미 한 번 영속 상태였기 때문에, 식별자 값을 가지고 있다.<br> <br>merge( )는 준영속 상태의 엔티티를 이용해서 새로운 영속 상태의 엔티티를 반환한다.<br> <br>실행되었을 때 일어나는 일<br> ① 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회<br>     (1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고 1차 캐시에 저장)<br> ② 조회한 영속 엔티티에 준영속 엔티티의 값을 채워 넣는다.<br> ③ 생성된 새로운 영속 엔티티를 반환한다.<br>새롭게 생성된 영속 상태의 엔티티를 가지고 이제 영속성 컨텍스트가 지원하는 기능을 사용할 수 있다.<br> <br>준영속 상태의 엔티티를 영속 상태로 변경하는 것이 아니라, 새로운 영속 상태의 엔티티를 만들어서,<br>준영속 상태의 엔티티 값을 영속 상태의 엔티티에 채워 넣어서 반환하는 점에 주의해야 한다.<br>그리고, 준영속 뿐만 아니라, 비영속 상태의 엔티티도 병합하여 새로운 영속 상태의 엔티티를 만들어 반환한다.<br> <br>자세한 내용은 위의 엔티티 변경 참조.<br> <br>(6) find( )<br>식별자 값을 가지고 엔티티를 찾아서 반환한다.<br>자세한 내용은 위의 엔티티 조회 참조<br> <br>(7) persist( )<br>자바 어플리케이션에서 생성된 엔티티를 영속성 컨텍스트와 데이터베이스에 저장한다.<br>자세한 내용은 위의 엔티티 생성 참조<br> <br>(8) remove( )<br>식별자 값을 가지고 엔티티를 찾아서 삭제한다.<br>자세한 내용은 위의 엔티티 삭제 참조</p>
<p>Query <br> 플랫폼 독립적인 객체지향 쿼리 언어를 사용하며, Query 인터페이스는 관계형 데이터베이스의 엔티티에 대한 쿼리를 만든다.</p>
<ul>
<li>특징<ul>
<li>JPQL : SQL문과 비슷하지만 데이터베이스의 테이블에 직접 연결되는 것이 아니라 JPA 엔티티에 대해 동작하게 된다.<ul>
<li>JPQL 쿼리의 칼럼은 엔티티의 필드 이름을 사용한다.</li>
</ul>
</li>
<li>Query Creation 매카니즘 : JPA에서의 쿼리 생성 매카니즘. 일반적으로 쿼리 메소드(Query method) 방식을 가장 많이 사용한다.<ul>
<li>JPA reference :  <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jpa/docs/1.10.1.RELEASE/reference/html/#jpa.sample-app.finders.strategies">https://docs.spring.io/spring-data/jpa/docs/1.10.1.RELEASE/reference/html/#jpa.sample-app.finders.strategies</a></li>
</ul>
</li>
<li>메타정보에 정의된 관계 정보를 이용하면 복잡한 Join 설정 등이 필요하지 않기 떄문에 훨씬 간결하다.</li>
</ul>
</li>
</ul>
<p>이 메소드 시그니처는 다음의 설정을 사용하여 스프링 MVC가 요청 파라미터로부터 Pageable 인스턴스를 만들어내게 시도합니다.<br>표 1. Pageable 인스턴스를 위해 평가된 요청파라미터 Request parameters evaluated for Pageable instances<br>page<br>얻기 원하는 페이지, 0 indexed and 기본은 0.<br>size<br>얻기 원하는 페이지 크기, 기본 20.<br>sort<br>다음의 형식으로 정렬될 형식 property,property(,ASC|DESC). 기본 정렬 방향은 오름차순(asc). 만약 방향을 바꾸고 싶은 여러개의sort 파라미터가 있다면 다음과 같이.., e.g. ?sort=firstname&amp;sort=lastname,asc.<br>이러한 행동을 커스터마이징 하고 싶다면 @Enable-어노테이션을 사용하는 대신에 SpringDataWebConfiguration를 상속하거나 HATEOAS-활성화 같은 것을 하거나, pageableResolver()나sortResolver()메소드를 오버라이드하고 당신의 커스터마이징된 설정파일을 임포트하세요.</p>
<p>이러한 경우 당신은 여러개의 테이블을 위해서, 요청으로부터 여러개의 Pageable 나 Sort 인스턴스가 resolved되기를 필요로 할지도 모릅니다. 예를 들자면 당신은 스프링의 @Qualifier어노테이션을 사용하여 다른 것들끼리 구별을 할 수도 있습니다. 요청파라미터는 그러면 ${qualifier}_로 prefixed됩니다. 그래서 메소드 시그니처가 다음과 같이 됩니다</p>
<p>JPA 함수 규칙</p>
<p>KeywordSampleJPQL snippet</p>
<p>And<br>findByLastnameAndFirstname<br>… where x.lastname = ?1 and x.firstname = ?2</p>
<p>Or<br>findByLastnameOrFirstname<br>… where x.lastname = ?1 or x.firstname = ?2</p>
<p>Is,Equals<br>findByFirstname,findByFirstnameIs,findByFirstnameEquals<br>… where x.firstname = ?1</p>
<p>Between<br>findByStartDateBetween<br>… where x.startDate between ?1 and ?2</p>
<p>LessThan<br>findByAgeLessThan<br>… where x.age &lt; ?1</p>
<p>LessThanEqual<br>findByAgeLessThanEqual<br>… where x.age &lt;= ?1</p>
<p>GreaterThan<br>findByAgeGreaterThan<br>… where x.age &gt; ?1</p>
<p>GreaterThanEqual<br>findByAgeGreaterThanEqual<br>… where x.age &gt;= ?1</p>
<p>After<br>findByStartDateAfter<br>… where x.startDate &gt; ?1</p>
<p>Before<br>findByStartDateBefore<br>… where x.startDate &lt; ?1</p>
<p>IsNull<br>findByAgeIsNull<br>… where x.age is null</p>
<p>IsNotNull,NotNull<br>findByAge(Is)NotNull<br>… where x.age not null</p>
<p>Like<br>findByFirstnameLike<br>… where x.firstname like ?1</p>
<p>NotLike<br>findByFirstnameNotLike<br>… where x.firstname not like ?1</p>
<p>StartingWith<br>findByFirstnameStartingWith<br>… where x.firstname like ?1 (parameter bound with appended %)</p>
<p>EndingWith<br>findByFirstnameEndingWith<br>… where x.firstname like ?1 (parameter bound with prepended %)</p>
<p>Containing<br>findByFirstnameContaining<br>… where x.firstname like ?1 (parameter bound wrapped in %)</p>
<p>OrderBy<br>findByAgeOrderByLastnameDesc<br>… where x.age = ?1 order by x.lastname desc</p>
<p>Not<br>findByLastnameNot<br>… where x.lastname &lt;&gt; ?1</p>
<p>In<br>findByAgeIn(Collection<Age> ages)<br>… where x.age in ?1</p>
<p>NotIn<br>findByAgeNotIn(Collection<Age> ages)<br>… where x.age not in ?1</p>
<p>True<br>findByActiveTrue()<br>… where x.active = true</p>
<p>False<br>findByActiveFalse()<br>… where x.active = false</p>
<p>IgnoreCase<br>findByFirstnameIgnoreCase<br>… where UPPER(x.firstame) = UPPER(?1)</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/16/JPA/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"
                            aria-label=": 생명주기"
                        >
                            생명주기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:52:26-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="리액트-내부-동작-순서-정리-life-cycle"><a href="#리액트-내부-동작-순서-정리-life-cycle" class="headerlink" title="리액트 내부 동작 순서 정리 (life cycle)"></a>리액트 내부 동작 순서 정리 (life cycle)</h1><p>컴포넌트가 생성 되었을 때 리액트가 동작하는 방식입니다.</p>
<ol>
<li>컴포넌트를 초기화 합니다. (constructor를 통해 state를 초기화, 기본 프롭스값)</li>
<li>componentWillMount API 가 실행 됩니다.<br>이  API 는 컴포넌트가 DOM 위에 만들어 지기 전에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서 DOM 처리는 불가능 합니다.</li>
</ul>
<ol start="3">
<li>렌더링을 진행합니다.</li>
<li>componentDidMount 는 렌더링이 완료되고 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서 다른 자바스크립트 프레임워크와 연동 및 setTimeout, setInteval, AJAX 등을 사용합니다.</li>
<li>DOM 처리가 가능합니다.</li>
</ul>
<p>두 번째 그래프는 프롭스가 변경되었을 때(전달 받을 때) 리액트가 동작하는 방식입니다.</p>
<ol>
<li>componentWillReceiveProps 는 상위 컴포넌트로 부터 props 를 받을 때 실행 됩니다.<br>이 단계는 props 에 따라 state 를 업데이트하는 경우에 사용하면 유용합니다.</li>
</ol>
<ul>
<li>이 단계에서 setState 를 해도 괜찮습니다.</li>
<li>componentWillReceiveProps API의 인자로 nextProps 가 들어옵니다. (바뀔 프롭스)</li>
</ul>
<ol start="2">
<li>shouldComponentUpdate 는 props 나 state 가 변경 되었을 때 다시 렌더링을 할지 말지 결정하는 API 입니다. <br>리턴값은 true 이거나 false 입니다.<br>만약 리턴값이 true 라면 다음 단계인 렌더링을 진행하지만, false 일 경우에는 Component Lifecycle 이 shouldComponentUpdate 단계에서 멈춥니다.</li>
</ol>
<ul>
<li>shouldComponentUpdate 의 인자로 nextProps 와 nextState 가 들어옵니다. (바뀔 프롭스와 스테이트)</li>
</ul>
<ol start="3">
<li>shouldComponentUpdate 리턴 값이 true 이면 다시 렌더링 합니다.</li>
<li>componentWillUpdate 는 컴포넌트가 업데이트 되기 전에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서는 스테이트를 변경하면 안 됩니다. (setState 사용금지, state 가 변경되면 리렌더링 해야함, 무한루프발생)</li>
</ul>
<ol start="5">
<li>componentDidUpdate 는 렌더링과 모든 업데이트가 완료된 후에 실행되는 API 입니다.</li>
</ol>
<ul>
<li>이 단계에서는 스테이트를 변경하면 안 됩니다. (setState 사용금지, state 가 변경되면 리렌더링 해야함, 무한루프발생)</li>
<li>componentDidUpdate 의 인자로 prevProps 와 prevState 가 들어옵니다. (변경되기 이전의 프롭스, 스테이트)</li>
</ul>
<p>세 번째 그래프는 스테이트가 변경되었을 때 리액트가 작동하는 방식으로, <br>shouldComponentUpdate -&gt; render -&gt; componentWillUpdate  -&gt; componentDidUpdate 순으로 동작합니다.</p>
<p>네 번째 그래프는 컴포넌트가 삭제 될 때의 API로, 컴포넌트가 DOM 에서 사라진 후 실행됩니다.</p>
<p>Component Lifecycle 을 이용하면 각 단계마다 다른 인터페이스를 보여주거나 로딩 중 일때 로딩 아이콘을 보여주거나 하는 작업을 쉽게 할 수 있습니다.</p>
<p>다음 포스팅에서는 지금까지 공부한 개념들을 바탕으로 간단한 어플리케이션을 만들어 보도록 하겠습니다.<br>감사합니다.</p>
<p>Jwt </p>
<ul>
<li>JWT(Json Web Token)는 웹표준 (RFC 7519)으로 JSON 포맷을 이용해 정보를 가볍고 안전하게 전송하기 위한 Claim 기반의 Web Token이다.</li>
<li>서버만 알고 있는 Secret Key로 디지털 서명화되어있기 때문에 신뢰할 수 있다</li>
<li>보통 Authorization (로그인, SSO) 또는 안전한 정보 교환을 위해 사용된다.</li>
<li>JWT에서는 토큰 자체에 유저 정보를 담아서 HTTP 헤더에 전달하기에 유저 세션을 유지할 필요가 없다.</li>
</ul>
<p>JWT의 필요성</p>
<ul>
<li>Session의 한계<ul>
<li>Cookie는 정보를 클라이언트 측에 저장하고 Session은 정보를 서버측에 저장한다.</li>
<li>따라서 유저의 수가 너무 많으면 서버 과부하</li>
</ul>
</li>
<li>Scale Out의 한계<ul>
<li>서버 확장(scale out)시 세션 정보 동기화 문제</li>
</ul>
</li>
<li>REST API는 Stateless를 지향<ul>
<li>사용자의 상태 정보를 저장하지 않는 형태 ex) 세션, 쿠키</li>
</ul>
</li>
</ul>
<p>동작 과정</p>
<ol>
<li>클라이언트 로그인 요청 POST(id, pw)</li>
<li>서버는 (id, pw)가 맞는지 확인 후 맞다면 JWT를 Secret Key로 생성 후 전달</li>
<li>클라이언트는 Token을 로컬 쿠키에 저장</li>
<li>클라이언트는 서버에 요청할 때 항상 헤더에 Token을 포함시킴</li>
<li>서버는 요청을 받을 때마다 Secret Kye를 사용해Token이 유효한지 검증<ul>
<li>서버만이 Secret Key를 가지고 있기 때문에 검증 가능</li>
<li>Token이 검증되면 따로 username, pw를 검사하지 않아도 user identification 가능</li>
</ul>
</li>
<li>서버의 Response</li>
</ol>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>레스트 호출 로직</p>
<p>1.[Axios란]<br>axios는 HTTP 클라이언트 라이브러리로써, 비동기 방식으로 HTTP 데이터 요청을 실행합니다.내부적으로 AXIOS는 직접적으로 XMLHttpRequest 를 다루지 않고 “AJAX 호출”을 할 수 있습니다.<br>promise를 객체로 리턴한다!</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EB%B0%94%EC%9D%B8%EB%94%A9/"
                            aria-label=": 바인딩"
                        >
                            바인딩
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:49:08-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>바인딩</p>
<p>자바스크립트에서 바인딩 (Javascript Binding)</p>
<p>자바스크립트에서 “this”에 대한 이해가 완벽히 되어있어야 한다.</p>
<p>자바스크립트에서 객체안의 메서드에서 this는 그 메서드가 포함된 object를 가리키게 된다.  </p>
<p>Var reference = obj.sayHello;<br>reference();</p>
<p>obj의 sayHello()를 다르게 출력해보면 undefined가 출력되는 것을 확인할 수 있다.<br>이 이유는 변수 reference에 담길 때 obj와의 관계가 상실되게 때문이다.<br>이럴 때 필요한 것이 “바.인.딩” 이다.</p>
<p>Var reference = obj.sayHello.bind(obj);<br>reference();</p>
<p>obj.sayHello()를 전달할 때 obj까지 바인딩시켜서 보내면 된다.<br>리액트에서도 마찬가지로 자바스크립트의 this가 사용되기때문에 바인딩이 필요하다.</p>
<p>리액트에서 바인딩 (React Binding)<br>React에서 컴포넌트에 이벤트메서드를 연결하는 방법 (=바인딩(binding))<br>다양한 방법이 있지만 리액트에서 주로 사용하는 방법은 컴포넌트의 생성자에서 바인딩 하기다.</p>
<p>class App extends React.Component {<br>    constructor() {<br>        super();<br>        this.state = {<br>              hidden: false,<br>        };<br>        this.update = this.update.bind(this);<br>    }<br>    update() {<br>        this.setState({<br>            hidden: true<br>        });<br>    }<br> <br>    render() {<br>        return &lt;div<br>            onClick={ this.update }<br>        /&gt;;<br>    }<br> <br>}</p>
<p>constructor() 에서 this.update = this.update.bind(this); 문장을 집어넣어서 바인딩시키면 render()에서 onClick={this.update}를 할 때 this가 App컴포넌트의 this라는 것을 알게 되는 것이다.</p>
<p>바인딩하는 방법중에 ‘autobind-decorator’를 사용해서 바인딩할 수 도 있다.<br>import autobind from ‘autobind-decorator’</p>
<p>mport React, { Component, PropTypes } from ‘react’;<br> <br>export default class Basic extends Component {<br>    state = {<br>           hidden: false,<br>      };<br> <br>      onClickButton = () =&gt; {<br>        this.setState(() =&gt; ({ hidden: true }));<br>      }<br>    <br>    render() {<br>        return (<br>              <div><br>                <button onClick={this.onClickButton}>숨기기</button><br>              </div><br>        );<br>    }<br>}</p>
<p>onClickButton 메서드를 “() =&gt;” arrow function으로 만들었다. (auto binding)<br>ES2015문법을 사용하는게 장기적으로 이득이니 적응하는게 좋을 듯 하다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EB%B0%94%EC%9D%B8%EB%94%A9/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"
                            aria-label=": 컴포넌트"
                        >
                            컴포넌트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:47:49-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="컴포넌트"><a href="#컴포넌트" class="headerlink" title="컴포넌트"></a>컴포넌트</h1><p> 컴포넌트란?</p>
<ul>
<li>컴포넌트 <br>처음 컴포넌트라는 이름을 들었을때 직관적으로 이해가 잘 안됬지만, 자바의 클래스와 객체로 분리하는 개념처럼 리액트에서는 컴포넌트로 분리한다고 생각하면 됩니다. 레이아웃을 컴포넌트라는 작은 단위로 나누어 코딩합니다. 이로인해 재사용성이 뛰어나고 이들을 모아 View형태로 코드를 짜기 때문에 코드도 이해하기 쉽고 협업에도 좋습니다.<br>React 컴포넌트는 상태 값을 이용해 UI를 표현합니다. 그리고, 컴포넌트 상태는 객체의 인스턴스 속성(Properties)을 이용해 관리하며 컴포넌트간에 단방향으로 데이터를 주고받는 props와 컴포넌트 내부에서 사용하는 state가 있습니다.</li>
</ul>
<p> - 기능을 단위별로 캡슐화하는 리액트의 기본 단컴포넌트란?<br> - 기능을 단위별로 캡슐화하는 리액트의 기본 단위다. <br> - 사용자가 보는 뷰는 이 컴포넌트들을 조합하여 만든다.<br> - 자바스크립트 함수 혹은 클래스이며 속성들을 이력받아들이며 내부적으로 각자의 상태를 관리한다.</p>
<p>리액트 컴포넌트는 요소를 그룹화하는 방법이다. <br>컴포넌트는 기능, 마크업, 스타일 그리고 기타 UI에 필요한 다른 요소들을 하나로 묶어 그룹화한다. <br>컴포넌트는 독립적이면서도 재사용이 가능하기 때문에 필요한 기능을 독자적으로 구성할 수 있다. </p>
<p>Data Flow</p>
<ul>
<li>단방향 데이터 흐름</li>
<li>데이터흐름 : 부모컴포넌트 =&gt; 자식컴포넌트</li>
<li>자식컴포넌트에서 직접적으로 부모컴포넌트에 전달하는 것은 불가능하다 - 간접적으로는 가능</li>
</ul>
<p>props<br>상위 컴포넌트가 하위 컴포넌트에게 내려주는 데이터 하위컴포넌트는 props를,</p>
<ul>
<li>단순히 사용만 할 수 있다</li>
<li>변경할 수 없다</li>
</ul>
<p>&lt;props 주는법&gt;</p>
<p>const App = () =&gt; (<br>  <div><br>    <h2>To Do List !</h2><br>    &lt;TodoList todos={[“eat pizza”, “eat rice”]} /&gt;<br>  </div><br>);</p>
<p>const TodoList = props =&gt; (<br>  <ul><br>    <li>{props.todos[0]}</li><br>    <li>{props.todos[1]}</li><br>  </ul><br>);</p>
<p>State<br>컴포넌트가 갖는 상태, 객체의 형태로 컴포넌트 내에서 보관하고 관리한다.</p>
<ul>
<li>class 컴포넌트로 작성되어야 한다</li>
<li>값을 변경할 땐 반드시 setState 메서드를 사용해야 한다</li>
<li>state 값이 변경되면 render() 함수가 실행된다.</li>
</ul>
<p>functional component vs class component</p>
<p>함수형 컴포넌트</p>
<ul>
<li>순수 자바스크립트 함수를 이용하여 컴포넌트를 정의한 것</li>
<li>선언하기가 편리하다</li>
<li>단순히 데이터를 받아들여 어떤 형태로 표시하기 때문에 ‘stateless’ 컴포넌트라고도 한다</li>
<li>주로 UI 렌더링을 담당한다 (예시 : Button 구성 요소)</li>
<li>state를 사용할 필요가 없는 경우 함수형 컴포넌트를 사용한다<ul>
<li>클래스형 컴포넌트보다 메모리 자원을 덜 사용한다</li>
</ul>
</li>
<li>state와 life cycle 기능을 사용할 수 없다 - v16.8 업데이트 이후 리액트 훅(Hooks)이라는 기능이 도입되어 사용이 가능하다고 한다..!!</li>
</ul>
<p>렌더링된 값들을 고정시킨다.</p>
<p>결과,</p>
<ul>
<li>함수형 컴포넌트 : Follow 버튼을 누르고 체크박스 옵션을 바꾸면 알림창에 Follow 버튼을 누르기전 옵션값이 알림창에 잘 들어가있다.</li>
<li>클래스형 컴포넌트 : Fllow 버튼을 누른 후 바꾼 옵션값이 알림창에 들어가있다<br>이 예제에서는 함수형 컴포넌트가 보여주는 패턴이 올바른 케이스이다. 내가 어떤 사람을 팔로우하고 다른 사람의 프로필로 이동했다 하더라도 컴포넌트가 이를 헷갈려서는 안된다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/01/09/%EB%B9%84%EB%8F%99%EA%B8%B0/"
                            aria-label=": 동기 비동기"
                        >
                            동기 비동기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-09T12:43:31-08:00">
	
		    Jan 09, 2021
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%EC%9D%B4%EB%A1%A0%EB%85%B8%ED%8A%B8/">이론노트</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="리액트-Async-Await"><a href="#리액트-Async-Await" class="headerlink" title="리액트 Async, Await"></a>리액트 Async, Await</h1><p>콜백함수 :</p>
<p>우리가 요청한 함수가 실행이 끝났을 때 우리에게 알려주는 함수</p>
<p>setTimeout 같은 함수는 콜백함수가 내장되어 있다!</p>
<p>Synchronous callback (print)</p>
<ul>
<li>받자마자 바로 콜백함수를 출력해주는 동기 콜백함수</li>
</ul>
<p>Asynchronous callback (print, timeout). -&gt; setTimeout 내장되어있음</p>
<ul>
<li>받고 일정 시간이 지나고 출력해주는 비동기 콜백함수</li>
</ul>
<p>이러한 콜백을 연결해서 코딩하게되면 콜백 지옥에 빠지게 된다.</p>
<ol>
<li>가독성이 떨어진다 어떻게 어디서 연결되어 있는지 알 수가 없다, 비즈니스 로직에 맞지않다.</li>
<li>디버깅 시 유지보수 하기가 어렵다</li>
</ol>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>Promise</p>
<p>프로미스의 3가지 상태(states)<br>프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 프로미스의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.</p>
<ul>
<li><p>Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태</p>
<p>먼저 아래와 같이 new Promise() 메서드를 호출하면 대기(Pending) 상태가 됩니다.<br>new Promise() 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject입니다.</p>
</li>
</ul>
<ul>
<li>Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태</li>
</ul>
<p>여기서 콜백 함수의 인자 resolve를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다.<br>그리고 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.</p>
<ul>
<li>Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태</li>
</ul>
<p>new Promise()로 프로미스 객체를 생성하면 콜백 함수 인자로 resolve와 reject를 사용할 수 있다고 했습니다. 여기서 reject를 아래와 같이 호출하면 실패(Rejected) 상태가 됩니다.<br>그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다.</p>
<p>비동기 방식으로 동작하지만 호출이 성공하면 그떄 바로 성공했다고 콜백해주는 것!</p>
<ol>
<li><p>State : Pending -&gt; fulfilled or rejected</p>
</li>
<li><p>Producer vs Consumer</p>
</li>
</ol>
<p>1)producer</p>
<p>Const promise = new  promise(( resolve , reject ) =&gt; {<br>    doing some heavy work (network, read files)<br>console.log(‘doing something…’);<br>resolve(‘Ellie’);<br>reject(new Error(’no network’));<br>});</p>
<p>—&gt; promise 를 만드는 순간 네트워크 통신을 하게 된다!<br>—&gt; 새로운 promise를 만드는 순간 executor가 자동으로 실행된다</p>
<p>Resolve : 통신이 성공 했을 때 호출하는 콜백함수<br>Reject : 통신에 실패 했을 때 호출하는 콜백함수</p>
<p>2)Consumers : then, catch, finally</p>
<p>1] then은 성공 했을 때 !<br>Promise.then( value =&gt; {<br>Console.log(value);<br>});</p>
<p>2] catch는 실패 했을 때!<br>.catch(error =&gt; {<br>console.log(error);<br>}</p>
<p>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ</p>
<p>Async &amp; await</p>
<ol>
<li>Async</li>
</ol>
<p>Async 를 앞에쓰면 promise가 자동으로 붙게된다 !<br>비동기로 처리 할 것을 명시한다!</p>
<ol start="2">
<li>Await</li>
</ol>
<p>비동기 처리가 일어날 때 await가 걸린 함수는 해당 함수의 호출이 끝날 때 까지 기다려준다!</p>
<p>Async await 병렬처리</p>
<p>Promise.all( [getApple(), getBanana()] )<br>  —&gt; 해당 함수에 모두 promise를 걸고 모든 함수를 병렬처리 한다! </p>
<p>promis.race( [getApple(), getBanana()] )<br> —&gt; 딱 하나만 제일 먼저 수행되는 애를 출력한다 !</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/01/09/%EB%B9%84%EB%8F%99%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2021/page/2/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 이상권. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">이상권</h4>
        
            <div id="about-card-bio"><p>미래의 백엔드 개발자</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>개발자</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Busan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover2.png');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
